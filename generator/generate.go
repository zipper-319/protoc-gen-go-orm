package generator

import (
	"fmt"
	"github.com/jinzhu/gorm"
	"github.com/jinzhu/inflection"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	gormopts "protoc-gen-go-orm/proto"
	"protoc-gen-go-orm/util"
	"strconv"
	"strings"
)

var (
	gormImport = "gorm.io/gorm"
	timeImport = "time"
)

type structTags [][2]string

func (tags structTags) String() string {
	if len(tags) == 0 {
		return ""
	}
	var ss []string
	for _, tag := range tags {
		// NOTE: When quoting the value, we need to make sure the backtick
		// character does not appear. Convert all cases to the escaped hex form.
		key := tag[0]
		val := strings.Replace(strconv.Quote(tag[1]), "`", `\x60`, -1)
		ss = append(ss, fmt.Sprintf("%s:%s", key, val))

	}
	return "`" + strings.Join(ss, " ") + "`"
}

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {

	//pathFrags := strings.Split(file.GeneratedFilenamePrefix, "/")
	//objectName := pathFrags[len(pathFrags)-1]
	//pathFrags[len(pathFrags)-1] = "sql"
	//fileName := fmt.Sprintf("%s_gorm.pb.go", objectName)
	//pathFrags = append(pathFrags, fileName)

	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+"_gorm.pb.go", file.GoImportPath)

	g.P("// code generated by protoc-gen-go-orm")
	g.P("// author zipper")
	g.P()
	g.P(`
package main

import (
	"gorm.io/gorm"
)
		`)
	//g.P("package ", file.GoPackageName)
	objList := make([]string, 0, len(file.Messages))
	for _, message := range file.Messages {
		msgOption := getMessageOptions(message)
		if msgOption != nil && msgOption.Ormable {
			objList = append(objList, fmt.Sprintf("%s%s", message.GoIdent.GoName, util.NAME_GO_SUFFIX))
			genMessageFields(g, message)
			generateTableNameFunctions(g, message)
		}
	}
	s := service{EntityObject: objList}
	g.P(s.execute())
	g.P()
	return g
}

func generateTableNameFunctions(g *protogen.GeneratedFile, message *protogen.Message) {
	msgOption := getMessageOptions(message)
	if msgOption != nil && msgOption.Ormable {
		typeName := string(message.Desc.Name())
		msgName := string(message.Desc.Name())

		g.P(`// TableName overrides the default tablename generated by GORM`)
		g.P(`func (`, typeName, util.NAME_GO_SUFFIX, `) TableName() string {`)

		tableName := inflection.Plural(gorm.ToDBName(msgName))
		if opts := getMessageOptions(message); opts != nil && len(opts.Table) > 0 {
			tableName = opts.GetTable()
		}
		g.P(`return "`, tableName, `"`)
		g.P(`}`)
		g.P()
	}
}

func genMessageFields(g *protogen.GeneratedFile, msg *protogen.Message) {
	msgOption := getMessageOptions(msg)
	g.P("type ", fmt.Sprintf("%s%s", msg.GoIdent.GoName, util.NAME_GO_SUFFIX), " struct {")
	for _, extraField := range msgOption.Include {
		fieldName := util.CamelCase(extraField.Name)
		fieldType := extraField.Type
		tag := extraField.Tag
		tags := structTags{
			{"json", fieldName},
			{"gorm", renderGormTag(tag, fieldName)},
		}

		g.P(fieldName, " ", fieldType, " ", tags)

	}
	for _, field := range msg.Fields {
		fd := field.Desc
		options := fd.Options().(*descriptorpb.FieldOptions)
		fieldOptions := getFieldOptions(options)
		if fieldOptions == nil {
			fieldOptions = &gormopts.GormFieldOptions{}
		}
		if fieldOptions.GetDrop() {
			continue
		}

		//tag := gormOptions.Tag
		fieldName := util.CamelCase(string(fd.Name()))

		goType, pointer := fieldGoType(g, field)
		if pointer {
			goType = "*" + goType
		}
		tags := structTags{
			{"json", fieldJSONTagValue(field)},
		}
		if gormTag := renderGormTagNew(fieldOptions, field.GoName); len(gormTag) > 0 {
			tags = append(tags, [2]string{"gorm", gormTag})
		}

		g.P(fieldName, " ", goType, " ", tags)
	}
	g.P("*gorm.Model")
	g.P("}")
	g.P()

}

func newGoIdent(nameGo string, importPath string) protogen.GoIdent {
	return protogen.GoIdent{
		GoName:       nameGo,
		GoImportPath: protogen.GoImportPath(importPath),
	}
}

func fieldJSONTagValue(field *protogen.Field) string {
	return string(field.Desc.Name()) + ",omitempty"
}

//func fieldProtobufTagValue(field *protogen.Field) string {
//	var enumName string
//	if field.Desc.Kind() == protoreflect.EnumKind {
//		enumName = protoimpl.X.LegacyEnumName(field.Enum.Desc)
//	}
//	return tag.Marshal(field.Desc, enumName)
//}

func getMessageOptions(message *protogen.Message) *gormopts.GormMessageOptions {
	options := message.Desc.Options()
	if options == nil {
		return nil
	}
	v := proto.GetExtension(options, gormopts.E_Opts)
	if v == nil {
		return nil
	}

	opts, ok := v.(*gormopts.GormMessageOptions)
	if !ok {
		return nil
	}

	return opts
}

func getFieldOptions(options *descriptorpb.FieldOptions) *gormopts.GormFieldOptions {
	if options == nil {
		return nil
	}

	v := proto.GetExtension(options, gormopts.E_Field)
	if v == nil {
		return nil
	}

	opts, ok := v.(*gormopts.GormFieldOptions)
	if !ok {
		return nil
	}

	return opts
}

func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind:
		goType = "*" + fmt.Sprintf("%s%s", field.Message.GoIdent.GoName, util.NAME_GO_SUFFIX)
		pointer = false // pointer captured as part of the type
	case protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := fieldGoType(g, field.Message.Fields[0])
		valType, _ := fieldGoType(g, field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}

func renderGormTag(tag *gormopts.GormTag, nameGo string) string {
	var gormRes string
	if tag == nil {
		tag = &gormopts.GormTag{}
	}

	if len(tag.Column) > 0 {
		gormRes += fmt.Sprintf("column:%s;", tag.GetColumn())
	}
	if len(tag.Type) > 0 {
		gormRes += fmt.Sprintf("type:%s;", tag.GetType())
	}
	if tag.GetSize() > 0 {
		gormRes += fmt.Sprintf("size:%d;", tag.GetSize())
	}
	if tag.Precision > 0 {
		gormRes += fmt.Sprintf("precision:%d;", tag.GetPrecision())
	}
	if tag.GetPrimaryKey() {
		gormRes += "primary_key;"
	}
	if tag.GetUnique() {
		gormRes += "unique;"
	}
	if len(tag.Default) > 0 {
		gormRes += fmt.Sprintf("default:%s;", tag.GetDefault())
	}
	if tag.GetNotNull() {
		gormRes += "not null;"
	}
	if tag.GetAutoIncrement() {
		gormRes += "auto_increment;"
	}
	if len(tag.Index) > 0 {
		if tag.GetIndex() == "" {
			gormRes += "index;"
		} else {
			gormRes += fmt.Sprintf("index:%s;", tag.GetIndex())
		}
	}
	if len(tag.UniqueIndex) > 0 {
		if tag.GetUniqueIndex() == "" {
			gormRes += "unique_index;"
		} else {
			gormRes += fmt.Sprintf("unique_index:%s;", tag.GetUniqueIndex())
		}
	}
	if tag.GetEmbedded() {
		gormRes += "embedded;"
	}
	if len(tag.EmbeddedPrefix) > 0 {
		gormRes += fmt.Sprintf("embedded_prefix:%s;", tag.GetEmbeddedPrefix())
	}
	if tag.GetIgnore() {
		gormRes += "-;"
	}

	return gormRes
}

func renderGormTagNew(field *gormopts.GormFieldOptions, nameGo string) string {
	var gormRes, atlasRes string
	tag := field.GetTag()
	if tag == nil {
		tag = &gormopts.GormTag{}
	}
	if len(tag.Column) > 0 {
		gormRes += fmt.Sprintf("column:%s;", tag.GetColumn())
	}
	if len(tag.Type) > 0 {
		gormRes += fmt.Sprintf("type:%s;", tag.GetType())
	}
	if tag.GetSize() > 0 {
		gormRes += fmt.Sprintf("size:%d;", tag.GetSize())
	}
	if tag.Precision > 0 {
		gormRes += fmt.Sprintf("precision:%d;", tag.GetPrecision())
	}
	if tag.GetPrimaryKey() {
		gormRes += "primaryKey;"
	}
	if tag.GetUnique() {
		gormRes += "unique;"
	}
	if len(tag.Default) > 0 {
		gormRes += fmt.Sprintf("default:%s;", tag.GetDefault())
	}
	if tag.GetNotNull() {
		gormRes += "not null;"
	}
	if len(tag.Constraint) > 0 {
		gormRes += fmt.Sprintf("constraint:%s;", tag.GetConstraint())
	}
	if tag.GetAutoIncrement() {
		gormRes += "autoIncrement;"
	}
	if len(tag.Index) > 0 {
		if tag.GetIndex() == "" {
			gormRes += "index;"
		} else {
			gormRes += fmt.Sprintf("index:%s;", tag.GetIndex())
		}
	}
	if len(tag.UniqueIndex) > 0 {
		if tag.GetUniqueIndex() == "" {
			gormRes += "uniqueIndex;"
		} else {
			gormRes += fmt.Sprintf("uniqueIndex:%s;", tag.GetUniqueIndex())
		}
	}
	if tag.GetEmbedded() {
		gormRes += "embedded;"
	}
	if len(tag.EmbeddedPrefix) > 0 {
		gormRes += fmt.Sprintf("embeddedPrefix:%s;", tag.GetEmbeddedPrefix())
	}
	if tag.GetIgnore() {
		gormRes += "-;"
	}

	if len(tag.GetSerializer()) > 0 {
		gormRes += fmt.Sprintf("serializer:%s;", tag.GetSerializer())
	}

	var foreignKey, associationForeignKey, joinTable, joinTableForeignKey, associationJoinTableForeignKey string
	var replace, append, clear bool
	if hasOne := field.GetHasOne(); hasOne != nil {
		foreignKey = hasOne.Foreignkey
		associationForeignKey = hasOne.AssociationForeignkey
		clear = hasOne.Clear
		replace = hasOne.Replace
		append = hasOne.Append
	} else if belongsTo := field.GetBelongsTo(); belongsTo != nil {
		foreignKey = belongsTo.Foreignkey
		associationForeignKey = belongsTo.AssociationForeignkey
	} else if hasMany := field.GetHasMany(); hasMany != nil {
		foreignKey = hasMany.Foreignkey
		associationForeignKey = hasMany.AssociationForeignkey
		clear = hasMany.Clear
		replace = hasMany.Replace
		append = hasMany.Append
		if len(hasMany.PositionField) > 0 {
			atlasRes += fmt.Sprintf("position:%s;", hasMany.GetPositionField())
		}
	} else if mtm := field.GetManyToMany(); mtm != nil {
		foreignKey = mtm.Foreignkey
		associationForeignKey = mtm.AssociationForeignkey
		joinTable = mtm.Jointable
		joinTableForeignKey = mtm.JointableForeignkey
		associationJoinTableForeignKey = mtm.AssociationJointableForeignkey
		clear = mtm.Clear
		replace = mtm.Replace
		append = mtm.Append
	} else {
		foreignKey = tag.Foreignkey
		associationForeignKey = tag.AssociationForeignkey
		joinTable = tag.ManyToMany
		joinTableForeignKey = tag.JointableForeignkey
		associationJoinTableForeignKey = tag.AssociationJointableForeignkey
	}

	if len(foreignKey) > 0 {
		gormRes += fmt.Sprintf("foreignKey:%s;", foreignKey)
	}

	if len(associationForeignKey) > 0 {
		gormRes += fmt.Sprintf("references:%s;", associationForeignKey)
	}

	if len(joinTable) > 0 {
		gormRes += fmt.Sprintf("many2many:%s;", joinTable)
	}
	if len(joinTableForeignKey) > 0 {
		gormRes += fmt.Sprintf("joinForeignKey:%s;", joinTableForeignKey)
	}
	if len(associationJoinTableForeignKey) > 0 {
		gormRes += fmt.Sprintf("joinReferences:%s;", associationJoinTableForeignKey)
	}

	if clear {
		gormRes += fmt.Sprintf("clear:%s;", strconv.FormatBool(clear))
	} else if replace {
		gormRes += fmt.Sprintf("replace:%s;", strconv.FormatBool(replace))
	} else if append {
		gormRes += fmt.Sprintf("append:%s;", strconv.FormatBool(append))
	}

	var gormTag, atlasTag string
	if gormRes != "" {
		gormTag = fmt.Sprintf("%s", strings.TrimRight(gormRes, ";"))
	}
	finalTag := strings.TrimSpace(strings.Join([]string{gormTag, atlasTag}, " "))
	if finalTag == "" {
		return ""
	} else {
		return fmt.Sprintf("%s", finalTag)
	}
}

func isOrmable(message *protogen.Message) bool {
	desc := message.Desc
	options := desc.Options()

	m, ok := proto.GetExtension(options, gormopts.E_Opts).(*gormopts.GormMessageOptions)
	if !ok || m == nil {
		return false
	}

	return m.Ormable
}
