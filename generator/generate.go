package generator

import (
	"fmt"
	jgorm "github.com/jinzhu/gorm"
	"github.com/jinzhu/inflection"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	gorm "protoc-gen-go-orm/proto"
	"protoc-gen-go-orm/util"
	"strconv"
	"strings"
)

var (
	gormImport = "gorm.io/gorm"
	timeImport = "time"
)

type structTags [][2]string

func (tags structTags) String() string {
	if len(tags) == 0 {
		return ""
	}
	var ss []string
	for _, tag := range tags {
		// NOTE: When quoting the value, we need to make sure the backtick
		// character does not appear. Convert all cases to the escaped hex form.
		key := tag[0]
		val := strings.Replace(strconv.Quote(tag[1]), "`", `\x60`, -1)
		ss = append(ss, fmt.Sprintf("%s:%s", key, val))
	}
	return "`" + strings.Join(ss, " ") + "`"
}

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	fileName := file.GeneratedFilenamePrefix + "_gorm.pb.go"
	g := gen.NewGeneratedFile(fileName, file.GoImportPath)
	g.P("// code generated by protoc-gen-go-orm")
	g.P("// author zipper")
	g.P()
	g.P("package ", file.GoPackageName)
	for _, message := range file.Messages {
		genMessageFields(g, message)
		generateTableNameFunctions(g, message)
	}
	g.P()
	return g
}

func generateTableNameFunctions(g *protogen.GeneratedFile, message *protogen.Message) {
	typeName := string(message.Desc.Name())
	msgName := string(message.Desc.Name())

	g.P(`// TableName overrides the default tablename generated by GORM`)
	g.P(`func (`, typeName, util.NAME_GO_SUFFIX, `) TableName() string {`)

	tableName := inflection.Plural(jgorm.ToDBName(msgName))
	if opts := getMessageOptions(message); opts != nil && len(opts.Table) > 0 {
		tableName = opts.GetTable()
	}
	g.P(`return "`, tableName, `"`)
	g.P(`}`)
	g.P()
}

func genMessageFields(g *protogen.GeneratedFile, msg *protogen.Message) {
	msgOption := getMessageOptions(msg)
	isOrmable := false
	g.P("type ", fmt.Sprintf("%s%s", msg.GoIdent.GoName, util.NAME_GO_SUFFIX), " struct {")
	if msgOption != nil && msgOption.Ormable {
		isOrmable = true
		for _, extraField := range msgOption.Include {
			fieldName := extraField.Name
			fieldType := extraField.Type
			tag := extraField.Tag
			tags := structTags{
				{"json", fieldName},
				{"gorm", renderGormTag(tag, fieldName)},
			}

			g.P(fieldName, " ", fieldType, " ", tags)

		}
	}

	for _, field := range msg.Fields {
		fd := field.Desc
		options := fd.Options().(*descriptorpb.FieldOptions)
		gormOptions := getFieldOptions(options)
		if gormOptions == nil {
			gormOptions = &gorm.GormFieldOptions{}
		}
		if gormOptions.GetDrop() {
			continue
		}

		//tag := gormOptions.Tag
		fieldName := util.CamelCase(string(fd.Name()))

		goType, pointer := fieldGoType(g, field)
		if pointer {
			goType = "*" + goType
		}
		tags := structTags{
			{"json", fieldJSONTagValue(field)},
		}
		if isOrmable {
			tags = append(tags, [2]string{"gorm", renderGormTag(gormOptions.GetTag(), field.GoName)})
		}
		g.P(fieldName, " ", goType, " ", tags)
	}
	g.P("*", g.QualifiedGoIdent(newGoIdent("Model", gormImport)))
	g.P("}")
	g.P()
}

func newGoIdent(nameGo string, importPath string) protogen.GoIdent {
	return protogen.GoIdent{
		GoName:       nameGo,
		GoImportPath: protogen.GoImportPath(importPath),
	}
}

func fieldJSONTagValue(field *protogen.Field) string {
	return string(field.Desc.Name()) + ",omitempty"
}

//func fieldProtobufTagValue(field *protogen.Field) string {
//	var enumName string
//	if field.Desc.Kind() == protoreflect.EnumKind {
//		enumName = protoimpl.X.LegacyEnumName(field.Enum.Desc)
//	}
//	return tag.Marshal(field.Desc, enumName)
//}

func getMessageOptions(message *protogen.Message) *gorm.GormMessageOptions {
	options := message.Desc.Options()
	if options == nil {
		return nil
	}
	v := proto.GetExtension(options, gorm.E_Opts)
	if v == nil {
		return nil
	}

	opts, ok := v.(*gorm.GormMessageOptions)
	if !ok {
		return nil
	}

	return opts
}

func getFieldOptions(options *descriptorpb.FieldOptions) *gorm.GormFieldOptions {
	if options == nil {
		return nil
	}

	v := proto.GetExtension(options, gorm.E_Field)
	if v == nil {
		return nil
	}

	opts, ok := v.(*gorm.GormFieldOptions)
	if !ok {
		return nil
	}

	return opts
}

func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind, protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := fieldGoType(g, field.Message.Fields[0])
		valType, _ := fieldGoType(g, field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}

func renderGormTag(tag *gorm.GormTag, nameGo string) string {
	var gormRes string
	if tag == nil {
		tag = &gorm.GormTag{}
	}

	if len(tag.Column) > 0 {
		gormRes += fmt.Sprintf("column:%s;", tag.GetColumn())
	} else {
		gormRes += fmt.Sprintf("column:%s;", util.SnakeCase(nameGo))
	}
	if len(tag.Type) > 0 {
		gormRes += fmt.Sprintf("type:%s;", tag.GetType())
	}
	if tag.GetSize() > 0 {
		gormRes += fmt.Sprintf("size:%d;", tag.GetSize())
	}
	if tag.Precision > 0 {
		gormRes += fmt.Sprintf("precision:%d;", tag.GetPrecision())
	}
	if tag.GetPrimaryKey() {
		gormRes += "primary_key;"
	}
	if tag.GetUnique() {
		gormRes += "unique;"
	}
	if len(tag.Default) > 0 {
		gormRes += fmt.Sprintf("default:%s;", tag.GetDefault())
	}
	if tag.GetNotNull() {
		gormRes += "not null;"
	}
	if tag.GetAutoIncrement() {
		gormRes += "auto_increment;"
	}
	if len(tag.Index) > 0 {
		if tag.GetIndex() == "" {
			gormRes += "index;"
		} else {
			gormRes += fmt.Sprintf("index:%s;", tag.GetIndex())
		}
	}
	if len(tag.UniqueIndex) > 0 {
		if tag.GetUniqueIndex() == "" {
			gormRes += "unique_index;"
		} else {
			gormRes += fmt.Sprintf("unique_index:%s;", tag.GetUniqueIndex())
		}
	}
	if tag.GetEmbedded() {
		gormRes += "embedded;"
	}
	if len(tag.EmbeddedPrefix) > 0 {
		gormRes += fmt.Sprintf("embedded_prefix:%s;", tag.GetEmbeddedPrefix())
	}
	if tag.GetIgnore() {
		gormRes += "-;"
	}

	return gormRes
}
